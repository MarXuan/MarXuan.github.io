<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <!-- Open Graph Data -->
  <meta property="og:title" content="探究一下volatile关键字"/>
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="Hexo"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Hexo</title>

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/css/bootstrap.min.css">

  <!-- Custom CSS -->
  
  
<link rel="stylesheet" href="/css/style.light.css">


  <!-- Google Analytics -->
  

<meta name="generator" content="Hexo 4.2.0"></head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">探究一下volatile关键字</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/<your-github-username>" target="_blank" rel="noopener">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:<your-email-address>">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By John Doe</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-03-03</span>
            <span class="time">10:26:04</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/java/">java</a>
</span>
          
        </div>
        <!-- Tags -->
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h1 id="探究一下volatile关键字"><a href="#探究一下volatile关键字" class="headerlink" title="探究一下volatile关键字"></a>探究一下volatile关键字</h1><p>​    之前一直以为volatile是能够保证线程安全的，后来才发现并不能，查阅资料后对volatile关键字有了更深的理解，所以今天写篇文章来探究并记录一下。</p>
<p>​    什么是volatile关键字，Java为什么要提供这个关键字，有什么用。简而言之，volatile修饰的变量对其他线程来说是立即可见的，并且对此变量操作的指令不会发生重排序。这是它的两大主要特征。这里提到了两个词：可见和重排序。什么是可见？在多线程操作里，每个线程从主存中读取到的<strong>共享变量</strong>的值总是最新的，乍一看，会觉得volatile是能够保证线程安全的，但其实不是，后面会讲到。那么什么是重排序？在执行一段程序的时候，处理器为了提高执行效率，会优化代码，不会按你写的代码的顺序来执行，但它会保证程序的最终结果不变，这就是指令重排序，还有一点就是重排序会考虑代码上下文的依赖，比如下一行指令会用到上一行指令的结果，那么这两行指令就不会被重排序。</p>
<h4 id="可见性是怎么实现的"><a href="#可见性是怎么实现的" class="headerlink" title="可见性是怎么实现的"></a>可见性是怎么实现的</h4><p>在说这个之前，先来了解几个概念。</p>
<p><strong>1.CPU缓存</strong>：我们都知道CPU的运算速度极快，而CPU读写内存的速度比起其运算速度很慢，所以为了弥补这种缺陷，在内存和CPU中间加入了高速缓存和寄存器，以此来匹配CPU的高速度。</p>
<p><strong>2.工作内存</strong>：作为开发人员也不可能去控制线程对高速缓存的同步，所以Java有一套机制：每个线程运行起来都会有自己工作内存，这个可以类比到多核计算机的每个CPU的高速缓存，高速缓存从内存里读写数据，同样的，每个线程的工作内存从主内存里读写数据，不过，两个主内存可不一样，前面那个是计算机的物理内存，后面那个是为jvm分配的内存，也可以理解成共享数据区。</p>
<p><strong>3.缓存行</strong>：CPU中的缓存是分段的，一段对应一个存储空间，称为缓存行，缓存行是CPU缓存中可分配的最小存储单元。</p>
<p><strong>4.总线锁</strong>：对总线进行加锁。当一个核对缓存中的变量进行操作时，就会对总线加一个lock#锁，其他核看到总线加锁了，就无法再去读取内存中的数据了。</p>
<p><strong>5.缓存一致性协议</strong>：总线锁的这种解决缓存不一致的方式有一个很大的缺点：效率低下。所以后来就出现了缓存一致性协议：当一个核要修改自己缓存中的变量时（这个变量是其他核共享的，每个核的缓存都有这个变量），其他核嗅探到这个核的修改情况，就会强制的将自己的缓存变量置为无效。当该处理器再访问此变量的时候，就会去主存读取。其中最著名的就是MESI协议。</p>
<p>​    当一个变量被volatile修饰时，在编译时会在指令前加一个lock汇编指令，处理器遇到这个lock时，会检查数据所在的区域，如果此数据在处理器的缓存中，则会锁住此缓存，处理完后把数据写回主存中，并采用缓存一致性协议来保证各处理器的缓存一致。</p>
<p>​    说到这里，你就会明白volatile的可见性是怎么保证的了吧</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>在多线程编程的三个特性中，有序性算是比较重要的了，如果不保证有序性，那么在经过指令重排序后，就可能会输出一些非法的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Main obj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Main <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                obj = <span class="keyword">new</span> Main();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，new 操作会执行三个操作</p>
<ol>
<li><p>分配内存</p>
</li>
<li><p>初始化内存</p>
</li>
<li><p>将引用执行内存，返回引用</p>
</li>
</ol>
<p>如果不加volatile的话，2.3步可能会发生重排序，导致其他线程返回的是一个只分配了内存但没有进行初始化的引用对象。</p>
<h4 id="volatile保证线程安全吗"><a href="#volatile保证线程安全吗" class="headerlink" title="volatile保证线程安全吗"></a>volatile保证线程安全吗</h4><p>答案是否定的，原因就是volatile不能保证原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    最后结果不是10000，是一个小于10000的数，为什么？因为inc++不是一个原子操作，是一个读、修改、写回的复合操作。比如线程1和线程2开始读取的inc都是10，然后线程1阻塞，线程2进行自增操作，将inc修改为11，写回主存，然后线程1再进行自增，此时线程1读取的inc是10，自增写回，两次自增操作后结果还是11。这是你可能会有疑问了，不是一个线程修改变量后会导致其他线程的缓存无效吗？对，没错，可是这里线程1已经早都执行了inc++操作了，只是读取完之后阻塞了，你再进行自增不可能再读一次数据吧，就算有可见性也没用，可见性来的太晚了，读这个原子操作已经结束了，在一个操作里面（不管是原子操作还是符合操作），都只能读取一次值，你得保证这个自增操作往下顺序执行吧。那么如果是另一种情况：线程1还没有执行inc++，没有读取inc，它的缓存里inc还是10，线程2执行了inc++，修改了inc，那么就会置线程1缓存行的inc无效，线程1进行inc++的时候发现自己的缓存无效了，就会从主存中读取新值，更新自己的缓存。这下明白了吧。</p>
<p>​    总结一句话：<strong>volatile对单个变量的读写具有原子性，比如赋值操作，不依赖当前值或其他变量；对变量的复合操作不具有原子性，比如自增操作i++、i+=3等等。</strong></p>
<p><strong>保证原子性怎么做？用synchronized、lock、AtomicInteger</strong></p>
<p>用volatile实现读写锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可见性保证最新的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 直接加锁保证对依赖当前值的操作具有原子性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>什么时候用volatile？一般会用在状态标记上，保证flag总是最新的。</strong></p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->

<script src="/js/highlight.pack.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

